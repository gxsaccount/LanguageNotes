## 左值和右值 ##  
左值：持久化对象，可以取地址的变量。  
右值：临时变量，不能取到地址的变量。  临时的值能够被识别、同时又能够被移动
-纯右值：纯粹的右值,要么是纯粹的字面量,例如10,true;要么是求值结果相当于字面量或匿名临时对象,例如1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda	表达式都属于纯右值。这些值都不能够被取地址。  
-将亡值：临时的值能够被识别、同时又能够被移动。   
## 右值引用和左值引用 ##  
右值引用：拿到一个将亡值的申明：T && ;一个声明的右值引用其实是一个左值。  

    std::string str0 = "holle move";
    std::string str = std::move(str0);

左值引用， 使用 T&, 只能绑定左值
右值引用， 使用 T&&， 只能绑定右值
常量左值， 使用 const T&, 既可以绑定左值又可以绑定右值
已命名的右值引用，编译器会认为是个左值
编译器有返回值优化，但不要过于依赖

**移动的语义**  
拷贝需要先将数据复制到一个临时变量再复制给变量。  
移动省略掉了复制的步骤，并将原来的引用失效，避免将数据消除。  

    class	A	{
    public:
            int	*pointer;
            A():pointer(new	int(1))	{	std::cout	<<	"构造"	<<	pointer	<<	std::endl;	}
            A(A&	a):pointer(new	int(*a.pointer))	{}	//无意义的对象拷贝
            A(A&&	a):pointer(a.pointer)	{	a.pointer	=	nullptr;}//移动后释放控制权
            ~A(){delete	pointer;	}//删除nullptr合法
    };
    
**完美转发**  
所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。(左引用保持左引用,右引用保持右引用)  
无论模板参数是什么类型的引用,当且仅当实参类型为右引用时,模板参数才能被推导为右引用类型。  
不完美转发：

    void process(int& i){
        cout << "process(int&):" << i << endl;
    }
    void process(int&& i){
        cout << "process(int&&):" << i << endl;
    }

    void myforward(int&& i){
        cout << "myforward(int&&):" << i << endl;
        process(i);
    }

    int main()
    {
        int a = 0;
        process(a); //a被视为左值 process(int&):0
        process(1); //1被视为右值 process(int&&):1
        process(move(a)); //强制将a由左值改为右值 process(int&&):0
        myforward(2);  //右值经过forward函数转交给process函数，却称为了一个左值，
        //原因是该右值有了名字  所以是 process(int&):2
        myforward(move(a));  // 同上，在转发的时候右值变成了左值  process(int&):0
        // forward(a) // 错误用法，右值引用不接受左值
    }
无论传递参数为左值还是右值,普通传参都会将参数作为左值进行转发.  

**move和forward比较**  
std::move(myClass);将调用myClass的移动构造函数,若没有,将调用拷贝构造函数.  
std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。  
std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。
std::move和std::forward只不过就是执行类型转换的两个函数；std::move没有move任何东西，std::forward没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。
std::forward<T>()不仅可以保持左值或者右值不变，同时还可以保持const、Lreference、Rreference、validate等属性不变；
