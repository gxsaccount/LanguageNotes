OpenMP采用fork-join的执行模式。开始的时候只存在一个主线程，当需要进行并行计算的时候，派生出若干个分支线程来执行并行任务。    
当并行代码执行完成之后，分支线程会合，并把控制流程交给单独的主线程。  

## 编译器指令 ##    
OpenMP的编译器指令的目标主要有：  
1）产生一个并行区域；  
2）划分线程中的代码块；  
3）在线程之间分配循环迭代；  
4）序列化代码段；  
5）同步线程间的工作。编译制导指令以#pragma omp 开始，后边跟具体的功能指令，格式如：#pragma omp 指令[子句],[子句] …]。常用的功能指令如下：  
parallel ：用在一个结构块之前，表示这段代码将被多个线程并行执行；  
for：用于for循环语句之前，表示将循环计算任务分配到多个线程中并行执行，以实现任务分担，必须由编程人员自己保证每次循环之间无数据相关性；  
parallel for ：parallel和for指令的结合，也是用在for循环语句之前，表示for循环体的代码将被多个线程并行执行，它同时具有并行域的产生和任务分担两个功能；  
sections ：用在可被并行执行的代码段之前，用于实现多个结构块语句的任务分担，可并行执行的代码段各自用section指令标出（注意区分sections和section）；  
parallel sections：parallel和sections两个语句的结合，类似于parallel for；  
single：用在并行域内，表示一段只被单个线程执行的代码；  
critical：用在一段代码临界区之前，保证每次只有一个OpenMP线程进入；  
flush：保证各个OpenMP线程的数据影像的一致性；  
barrier：用于并行域内代码的线程同步，线程执行到barrier时要停下等待，直到所有线程都执行到barrier时才继续往下执行；  
atomic：用于指定一个数据操作需要原子性地完成；  
master：用于指定一段代码由主线程执行；  
threadprivate：用于指定一个或多个变量是线程专用，后面会解释线程专有和私有的区别。  

 
相应的OpenMP子句为：   


private：指定一个或多个变量在每个线程中都有它自己的私有副本；  
firstprivate：指定一个或多个变量在每个线程都有它自己的私有副本，并且私有变量要在进入并行域或任务分担域时，继承主线程中的同名变量的值作为初值；  
lastprivate：是用来指定将线程中的一个或多个私有变量的值在并行处理结束后复制到主线程中的同名变量中，负责拷贝的线程是for或sections任务分担中的最后一个线程；   
reduction：用来指定一个或多个变量是私有的，并且在并行处理结束后这些变量要执行指定的归约运算，并将结果返回给主线程同名变量；  
nowait：指出并发线程可以忽略其他制导指令暗含的路障同步；  
num_threads：指定并行域内的线程的数目；   
schedule：指定for任务分担中的任务分配调度类型；  
shared：指定一个或多个变量为多个线程间的共享变量；  
ordered：用来指定for任务分担域内指定代码段需要按照串行循环次序执行；  
copyprivate：配合single指令，将指定线程的专有变量广播到并行域内其他线程的同名变量中；  
copyin n：用来指定一个threadprivate类型的变量需要用主线程同名变量进行初始化；  
default：用来指定并行域内的变量的使用方式，缺省是shared。  

## API函数 ##  
除上述编译制导指令之外，OpenMP还提供了一组API函数用于控制并发线程的某些行为   
函数名|函数作用  
-|-  
omp_in_parallel|判断当前是否在并行域    
omp_get_thread_num|返回线程号  
omp_set_num_threads|设置后续并行域中的线程格式  
omp_get_num_threads|返回当前并行域中的线程数
omp_get_max_threads|获取并行域可用的最大线程数
omp_get_num_procs|返回系统中处理器个数
omp_get_dynamic|判断是否支持动态改变线程数目
omp_set_dynamic|启动或关闭线程数目的动态改变
omp_get_nested|判断系统是否支持并行嵌套
omp_set_nested|启动或关闭并行嵌套

## 环境变量 #
 OpenMP提供了一些环境变量，用来在运行时对并行代码的执行进行控制。这些环境变量可以控制：  
 1）设置线程数；  
 2）指定循环如何划分；  
 3）将线程绑定到处理器；  
 4）启用/禁用嵌套并行，设置最大的嵌套并行级别；  
 5）启用/禁用动态线程；  
 6）设置线程堆栈大小；  
 7）设置线程等待策略。常用的环境变量：  

OMP_SCHEDULE：用于for循环并行化后的调度，它的值就是循环调度的类型；    
OMP_NUM_THREADS：用于设置并行域中的线程数；     
OMP_DYNAMIC：通过设定变量值，来确定是否允许动态设定并行域内的线程数；    
OMP_NESTED：指出是否可以并行嵌套。   

OpenMP指令及子句用法  
parallel   
parallel 是用来构造一个并行块的，也可以使用其他指令如for、sections等和它配合使用。  
parallel指令是用来为一段代码创建多个线程来执行它的。  
parallel块中的每行代码都被多个线程重复执行。  
和传统的创建线程函数比起来，相当于为一个线程入口函数重复调用创建线程函数来创建线程并等待线程执行完。  

*for*  

*section*  
section语句是用在sections语句里用来将sections语句里的代码划分成几个不同的段，每段都并行执行。  

    #pragma omp [parallel] sections [子句]
    {
       #pragma omp section{
                代码块
       } 
       #pragma omp section{
                代码块
       } 
    }


*private*  
private子句用于将一个或多个变量声明成线程私有的变量，变量声明成私有变量后，  
指定每个线程都有它自己的变量私有副本，其他线程无法访问私有副本。  
即使在并行区域外有同名的共享变量，共享变量在并行区域内不起任何作用，并且并行区域内不会操作到外面的共享变量。  


