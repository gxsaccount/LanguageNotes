1.利用sleep释放cpu资源  

    bool flag;
    std::mutex m;
    void wait_for_flag(){
        std::unique_lock<std::mutex> lk(m);
        while (!flag){
            lk.unlock();                                                 //	1	解锁互斥量
            std::this_thread::sleep_for(std::chrono::milliseconds(100)); //	2	休眠100ms
            lk.lock();                                                   //	3	再锁互斥量
        }
    }
    
 2.利用std::condition_variable和std::condition_variable_any等待条件达成  
  
    std::mutex mut;
    std::queue<data_chunk> data_queue; //	1.两个线程之间传递数据的队列
    std::condition_variable data_cond;
    void data_preparation_thread(){
        while (more_data_to_prepare()){
            data_chunk const data = prepare_data();
            std::lock_guard<std::mutex> lk(mut);//数据准备好时上锁
            data_queue.push(data);  //	2 将数据安全的压入队列
            data_cond.notify_one(); //	3 通知wait在data_cond上的线程
        }
    }
    void data_processing_thread(){
        while (true){
            std::unique_lock<std::mutex> lk(mut); //	4
            data_cond.wait(lk, [] { return !data_queue.empty(); }); //	5 等待在data_cond上，检查条件判断是否上锁
            data_chunk data = data_queue.front();
            data_queue.pop();
            lk.unlock(); //	6执行完解锁
            process(data);
            if (is_last_chunk(data))
                break;
        }
    }
    
wait()函数传入锁和检查条件，根据条件判断是否给锁的互斥量加锁。不加锁就阻塞，等待notify_one()/notify_all()通知，重新获取互斥锁,并且对条件再次检查。  
等待中的线程必须在等待期间解锁互斥量,并在这这之后对互斥量再次上锁,而std::lock_guard没有这么灵活。  

3.有返回值的线程：std::async//std::future<>与std::shared_future<>  
std::future<>与std::shared_future<>对应std::unique_ptr和	std::shared_ptr。  
std::future只能与一个指定事件相关联，std::shared_future能关联多个事件。  
与std::thread对象等待的方式不同,std::async会返回一个std::future对象。其他参数等与std::thread一样

    #include <future>
    #include <iostream>
    int find_the_answer_to_ltuae();
    void do_other_stuff();
    int main(){
        std::future<int> the_answer = std::async(find_the_answer_to_ltuae);//线程开启
        do_other_stuff();
        std::cout << "The	answer	is	" << the_answer.get() << std::endl;//获得返回值
    }


<tbody><tr height="18" style="height:13.8pt">
  <td height="18" width="264" style="height:13.8pt;width:198pt">类型/命名空间</td>
  <td width="247" style="width:185pt">函数</td>
  <td width="354" style="width:265pt">返回值</td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td rowspan="2" height="36" class="xl65" style="height:27.6pt">std::this_thread[namespace]</td>
  <td>sleep_for(duration)</td>
  <td rowspan="2" class="xl68" width="354" style="border-bottom:.5pt solid black;
  width:265pt">N/A<br>
    </td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td height="18" style="height:13.8pt">sleep_until(time_point)</td>
 </tr>
 <tr height="110" style="mso-height-source:userset;height:82.8pt">
  <td rowspan="2" height="147" class="xl68" width="264" style="height:110.4pt;
  width:198pt">std::condition_variable 或<br>
    std::condition_variable_any</td>
  <td class="xl66" width="247" style="width:185pt">wait_for(lock, duration)<br>
    </td>
  <td>std::cv_status:</td>
 </tr>
 <tr height="37" style="height:27.6pt">
  <td height="37" class="xl66" width="247" style="height:27.6pt;width:185pt">wait_until(lock,time_point)<br>
    </td>
  <td class="xl69">std::cv_status:</td>
 </tr>
 <tr height="37" style="height:27.6pt">
  <td rowspan="2" height="74" class="xl68" width="264" style="height:55.2pt;width:198pt"></td>
  <td class="xl66" width="247" style="width:185pt">wait_for(lock, duration,<br>
    predicate)</td>
  <td rowspan="2" class="xl71" width="354" style="border-top:none;width:265pt">bool
  —— 当唤醒时，返回谓果<br>
    </td>
 </tr>
 <tr height="37" style="height:27.6pt">
  <td height="37" class="xl66" width="247" style="height:27.6pt;width:185pt">wait_until(lock,
  duration,predicate)<br>
    </td>
 </tr>
 <tr height="110" style="mso-height-source:userset;height:82.8pt">
  <td rowspan="2" height="128" class="xl68" width="264" style="height:96.6pt;
  width:198pt">std::timed_mutex 或<br>
    std::recursive_timed_mutex</td>
  <td>try_lock_for(duration)</td>
  <td rowspan="2" class="xl68" width="354" style="width:265pt">bool ——
  获取锁时返回true，否则<br>
    返回fasle</td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td height="18" style="height:13.8pt">try_lock_until(time_point)</td>
 </tr>
 <tr height="55" style="height:41.4pt">
  <td rowspan="2" height="110" class="xl65" style="height:82.8pt">std:unique_lock&lt;TimedLockedable&gt;</td>
  <td>unique_lock(lockable, duration)</td>
  <td class="xl66" width="354" style="width:265pt">N/A —— 对新构建的对象调用<br>
    owns_lock();<br>
    </td>
 </tr>
 <tr height="55" style="height:41.4pt">
  <td height="55" class="xl66" width="247" style="height:41.4pt;width:185pt">unique_lock(lockable,<br>
    time_point)<br>
    </td>
  <td class="xl66" width="354" style="width:265pt">当获取锁时返回true，否则返回<br>
    false<br>
    </td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td rowspan="2" height="36" class="xl65" style="height:27.6pt"></td>
  <td>try_lock_for(duration)</td>
  <td rowspan="2" class="xl68" width="354" style="border-bottom:.5pt solid black;
  width:265pt">bool —— 当获取锁时返回true，否<br>
    则返回false</td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td height="18" style="height:13.8pt">try_lock_until(time_point)</td>
 </tr>
 <tr height="37" style="mso-height-source:userset;height:27.6pt">
  <td rowspan="4" height="147" class="xl68" width="264" style="height:110.4pt;
  width:198pt">std::future&lt;ValueType&gt;或<br>
    std::shared_future&lt;ValueType&gt;<br>
    </td>
  <td>wait_for(duration)</td>
  <td class="xl66" width="354" style="width:265pt">当等待超时，返回<br>
    std::future_status::t</td>
 </tr>
 <tr height="18" style="height:13.8pt">
  <td rowspan="3" height="110" class="xl65" style="height:82.8pt">wait_until(time_point)</td>
  <td></td>
 </tr>
 <tr height="37" style="height:27.6pt">
  <td height="37" class="xl66" width="354" style="height:27.6pt;width:265pt">当“期望”准备就绪时，返回<br>
    std::future_status::r</td>
 </tr>
 <tr height="55" style="height:41.4pt">
  <td height="55" class="xl66" width="354" style="height:41.4pt;width:265pt">当“期望”持有一个为启动的延迟函<br>
    数，返回<br>
    std::future_status::d</td>
 </tr>
 <!--[if supportMisalignedColumns]-->
 <tr height="0" style="display:none">
  <td width="264" style="width:198pt"></td>
  <td width="247" style="width:185pt"></td>
  <td width="354" style="width:265pt"></td>
 </tr>
 <!--[endif]-->
</tbody>
