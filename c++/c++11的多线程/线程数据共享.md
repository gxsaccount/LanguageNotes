## 互斥量 ##  
std::mutex//互斥量  
std::lockguard//锁上过后自动解锁  
问题1：指针和引用可以修改到被互斥量保护的数据  
问题2：在类似于stack这样的容器进行拷贝时，pop函数再犯会值到函数时拷贝抛出异常（如数据太多时的std::bad_alloc）,他从栈中被移除，但却未能拷贝到函数。
stack的做法将pop分为了top和pop，但这样制造了条件竞争。  
问题2解决：
-1.传入一个引用  
    
    //需要构造一个临时变量，浪费时间和空间
    //需要客赋值的类型
    std::vector<int> reslut; // 需要pop的数据类型
    some_stack.pop(result);  
-2.无异常抛出的拷贝或移动构造函数  
-3.返回指向弹出值的指针
--可以自由拷贝且不会产生异常，但需要对内存进行管理，对于简单数据类型如int，内存管理开销远大于直接返回值
-4.选项1+选项2 或者 选项1+选项3  


    #include <exception>
    #include <memory>
    #include <mutex>
    #include <stack>

    struct empty_stack : std::exception
    {
      const char *what() const throw()
      {
        return "empty	stack!";
      };
    };

    template <typename T>
    class threadsafe_stack
    {
    private:
      std::stack<T> data;
      mutable std::mutex m;

    public:
      threadsafe_stack(): data(std::stack<T>()) {}
      threadsafe_stack(const threadsafe_stack &other){
        std::lock_guard<std::mutex> lock(other.m);
        data = other.data; //	1	在构造函数体中的执行拷贝
      }

      threadsafe_stack &operator=(const threadsafe_stack &) = delete;//

      void push(T new_value){
        std::lock_guard<std::mutex> lock(m);
        data.push(new_value);
      }

      std::shared_ptr<T> pop(){
        std::lock_guard<std::mutex> lock(m);
        if (data.empty())
          throw empty_stack(); //	在调用pop前,检查栈是否为空
        std::shared_ptr<T> const res(std::make_shared<T>(data.top())); //	在修改堆栈前,分配出返回值
        data.pop();
        return res;
      }

      void pop(T &value){
        std::lock_guard<std::mutex> lock(m);
        if (data.empty())
          throw empty_stack();
        value = data.top();
        data.pop();
      }

      bool empty() const{
        std::lock_guard<std::mutex> lock(m);
        return data.empty();
      }
    };
