[内存管理的层级]
1、 C++标准库提供的std::allocator这个分配器。  
2、 C++的原生构件，比如new、new[ ]、::operator new等等。  
3、 C标准库函数malloc和free。  
4、 操作系统分配内存的函数，这个和操作系统有关，我们一般不会去操作。  

| 分配                   | 释放                     | 类属    | 可否重载               |
| ------------------------ | -------------------------- | --------- | -------------------------- |
| malloc()                 | free()                     | C函数   | 不可                     |
| new                      | delete                     | C++表达式 | 不可                     |
| ::operator new()         | ::operator delete()        | C++函数 | 可                        |
| allocator<T>::allocate() | allocator<T>::deallocate() | C++标准库 | 可以自由设计，搭配任何容器 |
    
四种内存管理函数使用方法   

    #include <iostream>
    #include <cstdlib>
    #include <complex>
    #include <ext/pool_allocator.h>
    #include "../include/test.h"
    using namespace std;

    int test1(){
        void *p1 = malloc(512);
        free(p1);

        complex<int>* p2 = new complex<int>;
        delete p2;

        void* p3 = ::operator new(512);
        ::operator delete(p3);

    #ifdef __GNUC__
        void* p4 = allocator<int>().allocate(7); 
        allocator<int>().deallocate((int*)p4, 7);         //在回收内存的时候需要指定回收的指针和回收的相应的个数，这个比较烦人
        cout << __GNUC__ << endl;
        cout << "正在使用GNU的分配器" << endl;

        //正在使用__gnu_cxx命名空间下的__pool_alloc分配器，这个分配器质量比较好
        void* p5 = __gnu_cxx::__pool_alloc<int>().allocate(9);
        __gnu_cxx::__pool_alloc<int>().deallocate(static_cast<int*>(p5), 9);
    #endif
        return 0;
    }

可以看到标准库自带的allocator分配器在回收内存空间的时候需要传入指针和相对应的元素个数  
_使用_gnu_cxx（一些比较好的std的扩展）命名空间下__pool_alloc这个分配器。std::allocator分配器只是对new和delete这两个函数进行了简单的包装，但是__pool_alloc这个分配器则是采用了内存池的技术，更加好一点  


## new/operator new/malloc 和析够delete ##   
本质上new调用operator new,而operator new调用malloc.  
析够/delete本质上调用free
        
        /*new*/
        Complex *pc = new Complex(1,2);  
        
        //编译器转化为类似如下代码
        Complex *pc;
        try{
            void* mem = operator new(sizeof(Complex));
            pc = static_cast<Complex*> mem;
            pc->Complex::Complex(1,2);//只有编译器可以用 ,若希望直接用ctor,只能用 new(p)Complex(1,2)
        }
        catch(std::bad_alloc){
            //
        }
        
        // operater new源码
        void * operater new(size_t size,const std::nothrow_t&)
                        _THROW0()
        {
            void* p;
            while((p=malloc(size))==0)//底层调用malloc
            {
                _TRY_BEGIN
                    if(_callnewh(size)==0) break;//_callnewh自己设定函数,通过自己释放一些内存来malloc
                _CATCH(std::bad_alloc) return(0);
                _CATCH_END
            }
        }
        
        
        /*delete*/
        Complex *pc = new Complex(1,2);
        ...
        delete pc;
        
        //编译器转化为如下代码  
        pc->~Complex();//先析够
        operator delete(pc);//然后释放内存  
        
        // operater delete源码
        void _cdecl operator delete(void *p)_THROW0()
        {
            free(p);
        }
        
   ## array new,array delete ##  
        
        Complex *pca = new Complex[3]; //构造顺序1,2,3
        //唤起三次ctor
        //无法调用有参数的构造函数即,必须有Complex()
        ...
        delete[] pca;//唤起三次dtor,释放顺序3,2,1  
        
