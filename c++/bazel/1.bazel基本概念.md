# Workspace #  
Bazel通过项目的目录结构来寻找每个package的配置(即BUILD文件),  
其中WORKSPACE文件所在的目录会被bazel识别为项目的根目录,标识为@,  
用来作为BUILD文件中的相对路径的根目录,以及保存编译的输出结果.  
# Repositories #  

# Packages #  
代码组织的基本单元,包含了相关文件和依赖,Packages可以包含Packages  
**一个Packages一定包含一个BUILD文件,反之亦然**   

     src/my/app/BUILD
     src/my/app/app.cc
     src/my/app/data/input.txt
     src/my/app/tests/BUILD
     src/my/app/tests/test.cc
 以上目录树包含两个包:my/app和subpackage的my/app/tests  
 
 
# Targets #  
package中的元素,主要为文件和规则,较少的有package groups  
**文件**分为源文件和派生文件(由源文件产生)  
**规则**指定一组输入和一组输出文件之间的关系，包括从输入中导出输出的必要步骤。  
规则的输出始终是生成的文件,规则的输入可以是源文件，但也可以是生成的文件;一条规则的输出可能是另一条规则的输入  
虽然规则的输入不一定来自于本包,但是规则生成的文件始终属于与规则本身相同的包  
**包组**是一组包,他用来限制一组包的访问性  
# Labels #   
targets的名称,格式为 //package name:target name,如下例子  

      //my/app:app
      //my/app
      :app
      app
      //my/app2:generate.cc
在包my/app的BUILD文件中,以上都是等价的.  
标签以//开头,my/app是包含//my/app的package,对于本包可以省略包名,  
对于文件而言，冒号被省略，规则则保留冒号 ??? ,  
来自外包的则不能有任何省略。    
# Lexical Specifications of a Label #   
标签名中不能有任何形式的空格和扩号,\*,>,&,|等,也不能用./和../等来表示目录信息.     
# Rules #
规则指定输入和输出之间的关系，以及构建输出的步骤。  
# BUILD Files #  
build文件不能包含函数定义,for和if声明???,但是可以使用列表推导和if表达式.  
函数应该在.bzl文件中声明。  
# 加载扩展程序 #  
Bazel扩展是以.bzl结尾的文件。  
使用load语句从扩展中导入符号。  

     load("//foo/bar:file.bzl", "some_library")  
     load("//foo/bar:file.bzl", library_alias = "some_library")  //别名,可以定义多个
     load(":my_rules.bzl", "some_rule", nice_alias = "some_other_rule")
此代码将加载文件foo/bar/file.bzl并将some_library符号添加到环境中。   
这可以用于加载新规则，函数或常量（例如字符串，列表等）  
# build rule的types #  
cc_binary ， cc_library和cc_test分别是C ++二进制文件，库和测试的构建规则。  
*_binary规则以给定语言构建可执行程序。  
*_test规则是*_binary规则的特化，用于自动化测试。  
*_library规则以给定的编程语言指定单独编译的模块。  

# Dependencies #  




