**1.先到bazel的workspace中**  
**2.bazel help**
  % bazel help
                             [Bazel release bazel-<version>]
  Usage: bazel <command> <options> ...

  Available commands:
    analyze-profile     Analyzes build profile data.
    aquery              Executes a query on the post-analysis action graph.
    build               Builds the specified targets.
    canonicalize-flags  Canonicalize Bazel flags.
    clean               Removes output files and optionally stops the server.

    cquery              Executes a post-analysis dependency graph query.

    dump                Dumps the internal state of the Bazel server process.

    help                Prints help for commands, or the index.
    info                Displays runtime info about the bazel server.

    fetch               Fetches all external dependencies of a target.
    mobile-install      Installs apps on mobile devices.

    query               Executes a dependency graph query.

    run                 Runs the specified target.
    shutdown            Stops the Bazel server.
    test                Builds and runs the specified test targets.
    version             Prints version information for Bazel.

  Getting more help:
    bazel help <command>
                     Prints help and options for <command>.
    bazel help startup_options
                     Options for the JVM hosting Bazel.
    bazel help target-syntax
                     Explains the syntax for specifying targets.
    bazel help info-keys
                     Displays a list of keys used by the info command.

**bazel build**  
 
    % bazel build 下列命令

    All target patterns starting with // are resolved relative to the current workspace.
    
    //foo/bar:wiz	Just the single target //foo/bar:wiz.
    //foo/bar	Equivalent to //foo/bar:bar.
    //foo/bar:all	All rules in the package foo/bar.
    //foo/...	All rules in all packages beneath the directory foo.
    //foo/...:all	All rules in all packages beneath the directory foo.
    //foo/...:*	All targets (rules and files) in all packages beneath the directory foo.
    //foo/...:all-targets	All targets (rules and files) in all packages beneath the directory foo.

    :foo	Equivalent to //foo:foo.
    bar:wiz	Equivalent to //foo/bar:wiz.
    bar/wiz	Equivalent to: //foo/bar/wiz:wiz if foo/bar/wiz is a package, //foo/bar:wiz if foo/bar is a package, //foo:bar/wiz otherwise.
    bar:all	Equivalent to //foo/bar:all.
    :all	Equivalent to //foo:all.
    ...:all	Equivalent to //foo/...:all.
    ...	Equivalent to //foo/...:all.
    bar/...:all	Equivalent to //foo/bar/...:all.
    
**build的patterns**  
    
    bazle build //foo/* == //foo/...:all-targets
    bazel build foo/... bar/...  将所有foo和bar的文件build
    bazel build -- foo/... -foo/bar/...  build 所有foo/下的target，除了foo/bar/下的
    
**fetch 外部依赖**  
    
    bazel fetch //...
    在bazel build之前bazel会自动run  
   https://docs.bazel.build/versions/master/guide.html#repository-cache
 
**缓存**  
缓存的默认地址是~/.cache/bazel/\_bazel\_$USER/cache/repos/v1/.，可以通过--repository_cache改变。  
缓存是所有workspaces和bazels的缓存。  
bazel使用SHA256 sum来判断文件是否在缓存中。  

**分发文件目录**  
使用--distdir选项，如果文件名等于URL的基本名称,且它们的hash值相等,则获取文件.这样，即使此类目录中的文件数量增大，指定分发文件目录仍然有效。  
???   

**构建配置和交叉编译**  
--build=编译该软件所使用的平台(你现在电脑的平台)  
--host=该软件将运行的平台(编译出来的库可以在哪个平台上运行)  
--target=该软件所处理的目标平台  
在build平台上编译工具程序,使得程序可以在host平台上处理target平台的程序.

可以将配置文件分为两个.  
host 配置:构建的规则,属性的值,和所有依赖关系包括传递依赖的结合.  
target/request 配置:target的结构，编译和链接选项以及其他**工具链配置**选项的选择。  

--distinct_host_configuration=false  
两个配置将会一样,在单个构建期间不需要构建两次库   
但是当target配置被修改了会影响到host配置,造成所有的tools需要被重新构建,依赖于工具输出的任何东西也需要rebuilt.  
--distinct_host_configuration=true (default)  
 If this option is true, then instead of using the same configuration for the host and request, a completely distinct host configuration is used. The host configuration is derived from the target configuration as follows:

    Use the same version of Crosstool (--crosstool_top) as specified in the request configuration, unless --host_crosstool_top is specified.
    Use the value of --host_cpu for --cpu (default: k8).
    Use the same values of these options as specified in the request configuration: --compiler, --use_ijars, If --host_crosstool_top is used, then the value of --host_cpu is used to look up a default_toolchain in the Crosstool (ignoring --compiler) for the host configuration.
    Use the value of --host_javabase for --javabase
    Use the value of --host_java_toolchain for --java_toolchain
    Use optimized builds for C++ code (-c opt).
    Generate no debugging information (--copt=-g0).
    Strip debug information from executables and shared libraries (--strip=always).
    Place all derived files in a special location, distinct from that used by any possible request configuration.
    Suppress stamping of binaries with build data (see --embed_* options).
    All other values remain at their defaults.

There are many reasons why it might be preferable to select a distinct host configuration from the request configuration. Some are too esoteric to mention here, but two of them are worth pointing out.

Firstly, by using stripped, optimized binaries, you reduce the time spent linking and executing the tools, the disk space occupied by the tools, and the network I/O time in distributed builds.

Secondly, by decoupling the host and request configurations in all builds, you avoid very expensive rebuilds that would result from minor changes to the request configuration (such as changing a linker options does), as described earlier.

That said, for certain builds, this option may be a hindrance. In particular, builds in which changes of configuration are infrequent (especially certain Java builds), and builds where the amount of code that must be built in both host and target configurations is large, may not benefit.   


**正确的增量重构**  
基于make的build工具不能正确的增量重构,因为make基于时间戳来判断文件是否该被rebuilt,  
问题1:在构建中断重新build时,构建有问题的文件将不会被rebuilt.  (because it is newer than its inputs???)   
问题2:在build命令的选项修改时,文件不会被rebuilt,make只检查文件而不知道命令被修改了,需要手动调用make clean.  
...  
Bazel维护一个完成的所有工作的数据库，如发现该构建步骤的输入文件集（及其时间戳）以及该构建步骤的编译命令与该构建步骤中的一个完全匹配，就会省略构建步骤  



