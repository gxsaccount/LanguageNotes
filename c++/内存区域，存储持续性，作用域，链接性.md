# 铺垫知识 #
## 1.内存相关知识 ##  
在C++中，内存分成5个区，他们分别是**栈、（堆、自由存储区）、全局/静态存储区、常量存储区**  
1.栈，编译器在需要时分配，不需要时候自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。  
2.堆，new分配的内存块，释放delete控制。没有delete程序结束后，操作系统会自动回收。  
  自由存储区，由malloc等分配的内存块，和堆是十分相似的，用free释放。  
3.全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分，他们共同占用同一块内存区。  
4.常量存储区，存放的是常量，不允许修改（通过非正当手段也可以修改）  

C++使用三种(C++11是四种)存储数据方案，他们区别在于数据保留在内存中的时间。  
**自动存储持续性**：  
  在函数定义中声明的变量(包括函数参数)的存储持续性为自动。随函数或代码块被创建和销毁。    
**静态存储持续性**：函数外定义和static修饰的变量，存储持续性都为静态。它们在程序整个运行过程中都存在。  
  C++为静态存储持续性变量提供了3种链接性：外部链接性(可在其他文件中访问)，内部链接性(只能在当前文件中访问)和无链接性(只能在当前函数或代码块中访问)。  
**线程存储持续性C++11**：  
  使用thread_local声明，其生命周期与所属的线程一样。  
**动态存储持续性**：  
  用new运分配的内存将一直存在，直到使用delete。这种内存的存储持续性为动态，有时被称为自由存储(free store)或堆(heap)。

## 2.作用域和链接 ##    
**链接性**描述了名称如何在不同单元间共享。  
  外部链接性：可在文件间共享。
  内部链接性：只能由一个文件中的函数共享。    
  无链接性：只能在当前函数或代码块访问，如自动变量。  
**作用域**描述了名称在文件的多大范围内可见。  
  作用域为局部的变量只在定义它的代码块中可用。  
  作用域为全局的变量在定义位置到文件结尾之间都可以用。  
  自动变量的作用域为局部。  
  静态变量的作用域是全局还是局部取决于它是如何被定义的。  
  在函数原型作用域中使用的名称只在包含参数列表的括号内可用。  
  在类中声明的成员作用域为整个类。  
  在命名空间中声明的变量的作用域为整个命名空间。  
  C++函数的作用域可以是整个类或整个命名空间，但不能是局部的(因为不能在代码块中定义函数)。      
 
# 变量的存储性和链接性 #
## 3.静态持续变量 ##   
-**静态变量初始化时先将所有位置为0**,然后执行静态初始化或动态初始化。    
-static语义：将修饰对象持续性变为静态。并不允许外部链接性。  
  
| 存储描述 | 持续性 | 作用域 | 链接性 | 如何声明 |
| ------ | ------ | ------ | ------ | ------ |
| 自动 | 自动 | 代码块 | 无 | 在代码块中(可使用关键字auto) |
| 寄存器 | 自动 | 代码块 | 无 | 在代码块中使用register |
| 静态，无链接性 | 静态 | 代码块 | 无 | 在代码块中使用关键字static |
| 静态，外部链接性 | 静态 | 文件 | 外部 | 在函数外面 |
| 静态，内部链接性 | 静态 | 文件 | 内部 | 在函数外面，使用关键字static |


## 4.限定符语义 ##  
static:修饰对象持续性变为静态。并不允许外部链接性（内部链接性或在函数中为无链接性）  
extern：外部链接性，声明引用在其他地方的变量  
thread_local:线程内部变量    
mutable:修饰变量可修改（比如使const类中的成员变得可修改）  
const:常量，值，类和结构的成员等均不能修改。默认修改为外部链接以下（内部链接性或在函数中为无链接性），可用extern修改为外部链接    
volatile:修饰变量禁用缓存寄存器优化    


# 函数的存储持续性和链接性 #  
## 存储持续性 ##  
不允许嵌套定义函数，只能为静态存续性。  
## 链接性 ##  
默认外部性  
static设为内部性  

## 语言链接性 ##  
extern  “[C|C++]” 

## 命名空间使用 ##  
