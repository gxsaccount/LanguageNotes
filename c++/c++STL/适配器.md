迭代器，容器，仿函数都有适配器。适配器使用组合的方式对它们进行改造。 
容器适配器：stack，queue，改造deque

# 仿函数适配器 #  
bind2nd，bind1st包装了binder2nd，binder1st
## 新型适配器 std::bind ##  
可以替换bind2nd，bind1st等等
1.functions 
2.functions objests
3.member functions,\_1必须时某个object地址
4.data members，\_1必须时某个object地址
5.静态成员函数对象则无需传递（因为静态不属于类？）
    #include <iostream>
    #include <memory>
    #include <functional> 

    using namespace std::placeholders;
    using namespace std;

    void fun1(int n1, int n2, int n3)
    {
        cout << n1 << " " << n2 << " " << n3 << endl;
    }
    
    
    /*普通函数*/
    int main()
    {
        //_1表示这个位置是新的可调用对象的第一个参数的位置
        //_2表示这个位置是新的可调用对象的第二个参数的位置  
        auto f1 = bind(fun1, _2, 22, _1);
        f1(44,55);
    }
    
    
      class A
      {
      public:
          int a;
          void print(int n1, int n2, int n3)
          {
              cout << n1 << " " << n2 << " " << n3 << endl;
          }
      };

      /*成员函数*/
      int main()                                                                                                                                   
      {
          A a;
          //类成员函数需要绑定该类的this指针  
          auto f1 = bind(&A::print, &a, _2, 22, _1);
          auto f2 = bind(&A::print, _1, _2, 22, _3);
          auto f3 = bind(&A::a, _1); //return a.a;
          f1(44,55);
          f2(a,44,55);
      }


# 迭代器适配器 #  
reverse_iterator  
inserter  


        /*copy 函数 */ 

        template<class InputIterator, class OutputIterator>
        OutputIterator copy(InputIterator first, InputIterator last, OutputIterator result)
        {
            while(first!=last){
              *result = *first;
              ++result;
              ++first;
            }

            return result;
        }
        /* inserter */
        template<class Container, class Iterator>
        inline insert_iterator<Container> inserter(Container &x, Iterator i)
        {
           typedef typename Container::iterator iter;
           return insert_iterator<Container>(x,iter(i));
        }
        
        /* insert_iterator */
        //通过重载操作符“=”，来为copy中“*result = *first”，增加越界检查
        template<class Container>
        class insert_iterator {
            protected: 
               Container* container;
               typename Container::iterator iter;
            public:
               typedef output_iterator_tag iterator_category;

            insert_iterator(Container& x, typename Container::iterator i): container(&x), iter(i) {}

            insert_iterator<Container> & operator=(const typename Container::value_type& value)
            {
               iter=container->insert(iter, value);//容器的insert， 有越界检查等
               ++iter;
               return *this;
            }   
        };
        
    int ints={10,20,30,40,50,70};
    vector<int> vec(7);
    copy(ints,ints+7,vec.begin()) // 此时可能会越界，如vector<int> vec(6); 

    vector<int>::iterator it = vec.begin();  
    copy(ints,ints+7,back_inserter(vec)); 
    copy(ints,ints+7,inserter(vec,it);    
