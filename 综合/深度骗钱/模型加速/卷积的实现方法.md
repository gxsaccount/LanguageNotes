## 计算方法 ##  
**FLOP/s**:每秒浮点运算数（FLoating Point Operations per Second，FLOP/s）  
**例子**:
    
CPU的配置:
  物理内核\*2  
  内核频率:2.5GHz,(每秒运行2.5×10^9个CPU循环)  
  每个循环可处理32 FLOPs（使用AVX & FMA）  
  CPU理论峰值性能为  
  ![](http://latex.codecogs.com/gif.latex?\\2*2.5*10^9\frac{cycles}{second}*32\frac{FLOP}{cycle}=160GFLOP/s)  
  理论峰值无法实现的原因在于，内存访问同样需要时间

## 存储形式 ##  
逻辑上矩阵/图像/张量是多维度的，实际上它们存储在**线性、一维**的计算机内存中。  
大部分现代深度学习库使用**行主序**作为存储顺序,即同一行的连续元素被存储在相邻位置.  
同时也意味着在线性扫描内存时第一个维度的变化速度最慢  
通常4维张量（如CNN中的张量）的存储顺序是NCHW(batch,channel,height,weight)、NHWC等  
[矩阵存储顺序]



## 1.朴素卷积(Naive Convolution) ##  
  
    for filter in (0,num_filters):
       for channel in (0,input_channels):
          for out_h in (0,output_height):  
              for out_w in (0,output_width):
                  for k_h in (0,kernel_height):
                      for k_w in (0,kernel_width):
                          output[filter, channel, out_h, out_h] +=   
                          kernel[filter, channel, k_h, k_w] *    
                          input[channel, out_h + k_h, out_w + k_w]
     
## 矩阵乘法和卷积:im2col ##  
下图展示了一个正常的3x3卷积：  
[3x3卷积]
下图展示的是该卷积运算被实现为矩阵相乘的形式。右侧的矩阵是im2col的结果，它需要从原始图像中复制像素才能得以构建。左侧的矩阵是卷积的权重，它们已经以这种形式储存在内存中。  
[转化为矩阵相乘]  
矩阵乘积直接得出了卷积输出，无需额外「转换」至原始形式  
*出于视觉简洁考虑，此处将每个图像块作为独立的个体进行展示。而在现实中，不同图像块之间通常会有重叠，因而im2col可能导致内存重叠。生成im2col 缓冲（im2col buffer）和过多内存（inflated memory）所花费的时间必须通过GEMM实现的加速来抵消。???*

## 加速矩阵相乘(GEMM) ##  
加速目标:C_{M*N}+=A_{M*K}*B_{K*N}  

**基础矩阵相乘时间**  
    
    for i in 0..M:    
        for j in 0..N:        
            for k in 0..K:            
                C[i, j] += A[i, k] * B[k, j]
    
**内存和cpu计算上的加速**  
内存RAM速度慢于cpu的缓存.  
CPU访问内存时会将临近数据加载(locality of reference)  
[加速前]
对于A:  
一旦我们找到 A[i, k]，则它在该行中的下一个元素A[i, k+1]已经被缓存了.  
对于B:  
列的下一个元素并未出现在缓存中，即出现了缓存缺失（cache miss）。这时尽管获取到了数据，CPU也出现了一次停顿。  
获取数据后，缓存同时也被 B 中同一行的其他元素填满。我们实际上并不会使用到它们，因此它们很快就会被删除。多次迭代后，当我们需要那些元素时，我们将再次获取它们。我们在用实际上不需要的值污染缓存。  
**重新修改loop，以充分利用缓存能力。**  
    
    for i in 0..M:    
        for k in 0..K:        
            for j in 0..N:
[加速后]  

**平铺(Tiling)**  
另一个缓存问题:  
对于A中的每一行，我们针对B中所有列进行循环。而对于 B 中的每一步，我们会在缓存中加载一些新的列，去除一些旧的列。当到达A的下一行时，我们仍旧重新从第一列开始循环。我们不断在缓存中添加和删除同样的数据，即缓存颠簸（cache thrashing）。  
如果所有数据均适应缓存，则颠簸不会出现。如果我们处理的是小型矩阵，则它们会舒适地待在缓存里，不用经历重复的驱逐。庆幸的是，我们可以将矩阵相乘分解为子矩阵。要想计算 C 的r×c平铺，我们仅需要A的r行和B的c列。接下来，我们将 C 分解为6x16的平铺：  
    
    C(x, y) += A(k, y) * B(x, k);
    C.update().tile(x, y, xo, yo, xi, yi, 6, 16)
    /*in pseudocode:for xo in 0..N/16:    
    for yo in 0..M/6:        
        for yi in 6:            
            for xi in 0..16:                
                for k in 0..K:                    
                    C(...) = ...*/  
